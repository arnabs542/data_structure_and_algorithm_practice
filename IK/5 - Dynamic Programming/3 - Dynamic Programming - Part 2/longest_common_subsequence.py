'''
Longest Common Subsequence
Problem Statement:
Given two strings a and b, find the longest common subsequence.
A subsequence is a sequence that can be derived from another sequence by zero or more elements, without changing the order
 of the remaining elements.
Find such longest subsequence which is common to both a and b. If multiple such subsequences occur, return any one of them
 and if no such subsequence found then return “-1”.
Input/Output Format For The Function:
Input Format:
There are two arguments, both strings a and b.
Output Format:
Return one string which is the longest common subsequence.
Input/Output Format For The Custom Input:
Input Format:
The first line in the input contains string a and next line contains string b.
ABCDE
AECBD
Output Format:
A string which is the longest common subsequence.
ABD
Constraints:
1 <= len(a), len(b) <= 400
Characters of string a and string b can be from [a, z], [A, Z] and [0-9].
Sample Test Case:
Sample Input:
ABCDE
AECBD
Sample Output:
ABD
Explanation:
ABD occurs in both ABCDE and AECBD in the same relative order as the subsequence. There is no other subsequence longer than
 3. Also, do note that ACD is also a valid subsequence of length 3, in such cases return any of them.
'''
import math
import os
import random
import re
import sys
sys.setrecursionlimit(1000100)


#
# Complete the 'lcs' function below.
#
# The function accepts STRING a and STRING b as parameter.
# The function is expected to return a STRING.
#
def lcs(a, b):
    pass




if __name__ == '__main__':
    f = sys.stdout
    a = input()
    b = input()
    result = lcs(a, b)
    f.write(result + '\n')
    f.close()


'''
We have provided solutions which contain necessary comments to understand the approach used:

1) brute_force_solution.java

Description:
Longest Common Subsequence problem takes two STRING as input and requires the longest common subsequence in both as output.
A subsequence is generated by deleting some/none character from a given string without changing their order.

To do this, start with index 0 of both the string, let index of String A at any point be ‘i’ and that of B be ‘j’ (initially i=j=0)
The index of the String implies the character that we are considering for including in the subsequence.

lcs_util(A, B, i, j):
- if the character at i in String A = character in String B at j, then this character can be part of the subsequence. Increment both i, j.
- else,
either the LCS includes the character at i in String A.
or, the LCS includes the character in String B at j.
or, the LCS excluding both the characters at i and j of String A and String B respectively.

As we do not know beforehand whether to exclude i or j, so proceed by doing both but at each step keep track of the longest substring returned.

For implementing else’s conditions:
the LCS includes the character at i in String A: we increment j and check for character match in the two Strings, at i and j (i.e. Move back to lcs_util(a, b, i, j+1))
the LCS includes the character in String B at j: we increment i and check for character match in the two Strings, at i and j (i.e. Move back to lcs_util(a, b, i+1, j))
the LCS excluding both the characters at i and j of String A and String B respectively: this is implicitly covered in 1 & 2 steps.

Example:

Let’s say String A: “ab” and String B: “aeb”



lcs_util(A, B, i, j) -> this method checks for the LCS of A, starting from ‘i’ to the end & B, starting from ‘j’ to the end.



lcs_util("ab", "aeb", 0, 0):

i=0, j=0: as character matches so LCS includes "a"

i=1, j=1: then check lcs_util("ab", "aeb", 1, 2) and lcs_util("ab", "aeb", 2, 1)

                    1. lcs_util("ab", "aeb", 1, 2) -> "ab"

                    2. lcs_util("ab", "aeb", 2, 1) -> "a"

          Max of the two is the answer which is "ab"



Time Complexity (assuming that input arguments are already given and excluding time used in the declaration of output):



O(2^(len_a+len_b)) where len_a and len_b are lengths of string A and string B respectively.



As for each character of the string, we are taking two possibilities whether it will be part of LCS or not. Hence total possibilities will be 2^(len_a+len_b) and hence time complexity will be O(2^(len_a+len_b)).



Time Complexity:



O(2^(len_a+len_b)) where len_a and len_b are lengths of string A and string B respectively.



As time complexity assuming that input arguments are already given and excluding time used in the declaration of output is O(2^(len_a+len_b)) and to read input strings of length len_a and len_b, it takes O(len_a) + O(len_b) and output string can be O(min(len_a, len_b)). Hence total complexity will be

O(2^(len_a+len_b)) + O(len_a) + O(len_b) + O(min(len_a, len_b)) →  O(2^(len_a+len_b)).



Auxiliary Space Used:



O(2^(len_a+len_b) * min(len_a, len_b)) where len_a and len_b are lengths of string A and string B respectively.



As we are calling our function to consider all possible LCS strings, it will take O(2^(len_a+len_b)) functional stack space and each call will store O(min(len_a, len_b)) add extra space to store intermediate generated strings. Hence, auxiliary space used will be O(2^(len_a+len_b) * min(len_a, len_b)).



Space Complexity:



O(2^(len_a+len_b) * min(len_a, len_b)) where len_a and len_b are lengths of string A and string B respectively.



As to store two input strings of length len_a and len_b, it will take O(len_a) + O(len_b). Auxiliary space used is O(2^(len_a+len_b) * min(len_a, len_b)) and for the output, string can take O(min(len_a, len_b)) of space. Hence total complexity will be

O(2^(len_a+len_b) * min(len_a, len_b)) + O(len_a) + O(len_b) + O(min(len_a, len_b)) →  O(2^(len_a+len_b) * min(len_a, len_b)).



2) sub_optimal_solution.java



Description:
In above-explained brute_force_solution, we can observe that it is repeatedly calculating already calculated subproblems. We can avoid it by using memorization.
For example in LCS(A, B, 0, 0), LCS(A, B, 1, 1) is called twice.

https://i.imgur.com/uKQBkrt.png   

The whole thing can be optimized by storing the calculation the first time it is calculated and reusing the same in subsequent requirements.
We are maintaining dp states, where dp[i][j] means the LCS for String A starting from 'i' to the end and String B, starting from 'j' to the end.

Time Complexity (assuming that input arguments are already given and excluding time used in the declaration of output):
O(len_a * len_b) where len_a and len_b are lengths of string A and string B respectively.

As we are maintaining dp states, where for dp[i][j]; 0<=i<=len_a and 0<=j<=len_b. And for completely filling this 2d array we are recursively calling lcs_util function len_a * len_b times.
Hence complexity will be O(len_a * len_b).
Time Complexity:
O(len_a * len_b) where len_a and len_b are lengths of string A and string B respectively.

As time complexity assuming that input arguments are already given and excluding time used in the declaration of output is O(len_a * len_b) and to read input strings of length len_a and len_b, it takes O(len_a) + O(len_b) and output string can be O(min(len_a, len_b)). Hence total complexity will be
O(len_a * len_b) + O(len_a) + O(len_b) + O(min(len_a, len_b)) →  O(len_a * len_b).

Auxiliary Space Used:
O(len_a * len_b * min(len_a, len_b)) where len_a and len_b are lengths of string A and string B respectively.

As we are calling our lcs_util function to fill our maintained 2d array dp, it will take O(len_a * len_b) functional stack space and each call will store O(min(len_a, len_b)) add extra space to store intermediate generated strings. Hence, auxiliary space used will be O(len_a * len_b * min(len_a, len_b)).

Space Complexity:
O(len_a * len_b * min(len_a, len_b)) where len_a and len_b are lengths of string A and string B respectively.

As to store two input strings of length len_a and len_b, it will take O(len_a) + O(len_b). Auxiliary space used is O(len_a * len_b * min(len_a, len_b)) and for the output, string can take O(min(len_a, len_b)) of space. Hence total complexity will be
O(len_a * len_b * min(len_a, len_b)) + O(len_a) + O(len_b) + O(min(len_a, len_b)) →  O(len_a * len_b * min(len_a, len_b)).

3) optimal_solution.java
Description:
In this approach, we are trying to divide our problem of finding the longest common subsequence into two subproblems.
To calculate the length of the longest common subsequence: For this, we will also maintain states in 2d array L which will also help in solving the second subpart.
Create subsequence from maintained states while calculating the length of LCS.

Dp state in 2d array L where L[i][j] contains length of LCS of a[0..i-1] and b[0..j-1].

To calculate the length of the LCS:
We will fill our maintained 2d array L (where 0 <= i < length of a and 0 <= j < length of b) with

If i == 0 or j == 0 then L[i][j] = 0.
If a[i-1] == b[j-1] then L[i][j] = L[i-1][j-1] + 1.
Else L[i][j] = max(L[i-1][j], L[i][j-1]).

Now we know the length of LCS as L[length of a - 1][length of b - 1] and we have maintained dp state to create required subsequence out of it.
We create a character array lcs of length L[length of a - 1][length of b - 1].
We will start from right-most-bottom-most corner i.e. i = length of a - 1 and j = length of b - 1.
If the character at index i of string a and character at index j of string b are same then that character will be part of our LCS and we fill our character array lcs reduce values of both i and j.
Else we will compare L[i-1][j] and L[i][j-1].
If L[i-1][j] > L[i][j-1], reduce i.
Else reduce j.
We will do this till i>0 & j>0.

And by now we got our final longest common subsequence characters stored in character array lcs.

For better understanding please look at optimal_solution.java.
Time Complexity (assuming that input arguments are already given and excluding time used in the declaration of output):
O(len_a * len_b) where len_a and len_b are lengths of string A and string B respectively.

We are filling maintained 2d array L of size len_a * len_b, it will take O(len_a * len_b) also we are filling character array lcs of size min(len_a, len_b) in worst case, so it will take O(min(len_a, len_b)).
Hence total complexity will be O(len_a * len_b) + O(min(len_a, len_b)) → O(len_a * len_b).

Time Complexity:
O(len_a * len_b) where len_a and len_b are lengths of string A and string B respectively.

As time complexity assuming that input arguments are already given and excluding time used in the declaration of output is O(len_a * len_b) and to read input strings of length len_a and len_b, it takes O(len_a) + O(len_b) and output string can be O(min(len_a, len_b)). Hence total complexity will be
O(len_a * len_b) + O(len_a) + O(len_b) + O(min(len_a, len_b)) →  O(len_a * len_b).

Auxiliary Space Used:
O(len_a * len_b) where len_a and len_b are lengths of string A and string B respectively.

As we are maintaining 2d array L of size len_a * len_b, it will consume space of  O(len_a * len_b) and also we are maintaining character array of size min(len_a, len_b) in worst case, it will take O(min(len_a, len_b)). Hence, total auxiliary space used will be O(len_a * len_b)  + O(min(len_a, len_b)) → O(len_a * len_b).

Space Complexity:
O(len_a * len_b) where len_a and len_b are lengths of string A and string B respectively.
As to store two input strings of length len_a and len_b, it will take O(len_a) + O(len_b). Auxiliary space used is O(len_a * len_b) and for the output, string can take O(min(len_a, len_b)) of space. Hence total complexity will be
O(len_a * len_b) + O(len_a) + O(len_b) + O(min(len_a, len_b)) →  O(len_a * len_b).
'''
'''
BRUTE FORCE
import java.io.*;
import java.util.*;

class Result {

    // ============================ Start ============================
    static String lcs(String a, String b) {
        // Calling function lcs_util with index pointing to starting of both strings
        String answer = lcs_util(a, b, 0, 0);
        answer = answer.trim();
        return answer.length() == 0 ? "-1" : answer;
    }

    // This method returns the LCS of str1, starting from 'i' to the end & str2, starting from 'j' to the end
    static String lcs_util(String str1, String str2, int i, int j) {

        if(i >= str1.length() || j >= str2.length()){
            return "";
        }

        // excluding_ith gives the LCS with str1 starting at (i+1), which means excluding 'i' whereas,
        // excluding_jth gives the LCS with str2 starting at (j+1), which means excluding 'j' and str1 starting at 'i'.
        String excluding_ith = lcs_util(str1, str2, i + 1, j);
        String excluding_jth = lcs_util(str1, str2, i, j + 1);

        // longer among excluding_ith and excluding_jth can be a possible answer.
        String ans = (excluding_ith.length() > excluding_jth.length()) ? excluding_ith : excluding_jth;

        // if char at 'i' in str1 == char at 'j' in str2, then this character can be included in the LCS,
        // if by excluding (i.e. 'ans' calculated above) it we dont get the LCS.
        if (str1.charAt(i) == str2.charAt(j)) {
            String excluding_both = lcs_util(str1, str2, i + 1, j + 1);
            return (1 + excluding_both.length()) > ans.length() ? (str1.charAt(i) + excluding_both) : ans;
        }
        return ans;
    }
    // ============================= End ==============================
}

class Solution {
    public static void main(String args[]) {
        /*
        This function is used to increase the size of recursion stack. It makes the size of stack
        2^26 ~= 10^8
        */
        new Thread(null, new Runnable() {
            public void run() {
                try{
                    solve();
                }
                catch(Exception e){
                    e.printStackTrace();
                }
            }
        }, "1", 1 << 26).start();
    }
    public static void solve() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out));

        String a = bufferedReader.readLine().trim();
        String b = bufferedReader.readLine().trim();

        String result = Result.lcs(a, b);
        bufferedWriter.write(result+"\n");
        bufferedWriter.close();
    }
}
'''
'''
OPTMIAL SOLUTION
import java.io.*;
import java.lang.reflect.Member;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;

class Result {

    // ============================ Start ============================
    // Returns String of LCS for a[0..m-1], b[0..n-1] 
    public static String lcs(String a, String b) {
        int len_a = a.length(), len_b = b.length();
        int[][] L = new int[len_a+1][len_b+1];

        // Following steps build L[m+1][n+1] in bottom up fashion. Note
        // that L[i][j] contains length of LCS of a[0..i-1] and b[0..j-1]
        for (int i=0; i<=len_a; i++) { 
            for (int j=0; j<=len_b; j++) { 
                if (i == 0 || j == 0) {
                    L[i][j] = 0;
                }
                else if (a.charAt(i-1) == b.charAt(j-1)) {
                    L[i][j] = L[i-1][j-1] + 1;
                }
                else {
                    L[i][j] = Math.max(L[i-1][j], L[i][j-1]);
                }
            }
        }

        // Following code is used to print LCS
        int index = L[len_a][len_b];
        int temp = index;

        // Create a character array to store the lcs string
        char[] lcs = new char[index+1];
        lcs[index] = ' '; // Set the terminating character

        // Start from the right-most-bottom-most corner and
        // one by one store characters in lcs[]
        int i = len_a, j = len_b;
        while (i > 0 && j > 0) {
            // If current character in a and b are same, then
            // current character is part of LCS
            if (a.charAt(i-1) == b.charAt(j-1)) {
                // Put current character in result
                lcs[index-1] = a.charAt(i-1);

                // reduce values of i, j and index
                i--;
                j--;
                index--;
            }

            // If not same, then find the larger of two and
            // go in the direction of larger value
            else if (L[i-1][j] > L[i][j-1]) {
                i--;
            }
            else {
                j--;
            }
        }
        String answer = new String(lcs);
        answer = answer.trim();
        return answer.length() == 0 ? "-1" : answer;
    }
    // ============================ End =============================
}


class Solution {
    public static void main(String args[]) {
        /*
        This function is used to increase the size of recursion stack. It makes the size of stack
        2^26 ~= 10^8
        */
        new Thread(null, new Runnable() {
            public void run() {
                try{
                    solve();
                }
                catch(Exception e){
                    e.printStackTrace();
                }
            }
        }, "1", 1 << 26).start();
    }
    
    public static int MAX_LENGTH = 100000;

    public static void solve() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out));

        String a = bufferedReader.readLine().trim();
        String b = bufferedReader.readLine().trim();

        String result = Result.lcs(a, b);
        bufferedWriter.write(result+"\n");
        bufferedWriter.close();
    }
}
'''
